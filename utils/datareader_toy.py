# import sys
# from collections import Counter
# from itertools import chain
# from typing import List
# import pandas as pd
# import json
# import csv

# import matplotlib.pyplot as plt

import numpy as np
import cv2
import os
import imageio
from torch.utils.data import Dataset


DATA_PATH = "../data/toydataset/" #path to data stored
NUM_TRAIN = 3500
NUM_TEST = 500
NUM_VAL = 1000


class toyScenesdata(Dataset):

    def __init__(self, set_name="train"):        

        self.set_name = set_name

        assert(self.set_name in ["train", "test", "val"])
        #read the scenes and trajectory arrays generated by the toy dataset
        self.scenes = os.listdir(DATA_PATH)
        print("Read in %d " % (len(self.scenes)))

        #get the training set
        self.train_idx = np.random.choice(5000,NUM_TRAIN, replace = False)        
        self.train_scenes = list(map(self.scenes.__getitem__,self.train_idx))

        #get remaining idxes
        self.test_val_idx = list(filter(lambda elem: elem not in self.train_idx,range(NUM_TRAIN+NUM_VAL+NUM_TEST)))

        #get test set
        self.test_idx = np.random.choice(self.test_val_idx,NUM_TEST, replace = False)
        self.test_scenes = list(map(self.scenes.__getitem__,self.test_idx))

        #get val set
        self.val_idx = list(filter(lambda elem: elem not in self.test_idx and elem not in self.train_idx,range(NUM_TRAIN+NUM_VAL+NUM_TEST)))
        self.val_scenes = list(map(self.scenes.__getitem__,self.val_idx))
        
        

    def __len__(self):
        if self.set_name == "train":
            return len(self.train_idx)
    
        if self.set_name == "test":
            return len(self.test_idx)
    
        if self.set_name == "val":
            return len(self.val_idx)

    def __getitem__(self, test_idx):
        
        #get the scene
        if self.set_name == "train":
            scene = self.train_scenes[test_idx]        
    
        if self.set_name == "test":
            scene = self.test_scenes[test_idx]        
    
        if self.set_name == "val":
            scene = self.val_scenes[test_idx]        
                

        coords = np.load(DATA_PATH+scene+"/ls.npy", allow_pickle=True)
        env_map = np.array(cv2.imread(DATA_PATH+scene+"/scene.png"))
        gt = np.array(np.load(DATA_PATH+scene+"/init.npy", allow_pickle=True))
        new_gt = np.zeros((2,9))
        count = 0
        for sublist0,sublist1 in zip(gt[0,:],gt[1,:]):
            if type(sublist0)!=int:
                for item0,item1 in zip(sublist0,sublist1):
                    new_gt[0,count] = item0
                    new_gt[1,count] = item1
                    count += 1
            else:
                new_gt[0,count] = item0
                new_gt[1,count] = item1
                count += 1
        #Initialise dictionary for returning data
        output_data = {"map":env_map, "coords":coords, "ground_truth":new_gt}

        return output_data




